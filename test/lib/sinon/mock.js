/**
 * @depend ../sinon.js
 * @depend stub.js
 */
/*jslint indent: 2, eqeqeq: false, onevar: false, nomen: false*/
/*global module, require, sinon*/
/**
 * Mock functions.
 *
 * @author Christian Johansen (christian@cjohansen.no)
 * @license BSD
 *
 * Copyright (c) 2010 Christian Johansen
 */
(function (sinon) {
  var commonJSModule = typeof module == "object" && typeof require == "function";

  if (!sinon && commonJSModule) {
    sinon = require("sinon");
  }

  if (!sinon) {
    return;
  }

  function mock(object) {
    if (!object) {
      return sinon.expectation.create("Anonymous mock");
    }

    return mock.create(object);
  }

  sinon.mock = mock;

  sinon.extend(mock, function () {
    function each(collection, callback) {
      if (!collection) {
        return;
      }

      for (var i = 0, l = collection.length; i < l; i += 1) {
        callback(collection[i]);
      }
    }

    return {
      create: function create(object) {
        if (!object) {
          throw new TypeError("object is null");
        }

        var mockObject = sinon.extend({}, mock);
        mockObject.object = object;
        delete mockObject.create;

        return mockObject;
      },

      expects: function expects(method) {
        if (!method) {
          throw new TypeError("method is falsy");
        }

        if (!this.expectations) {
          this.expectations = {};
          this.proxies = [];
        }

        if (!this.expectations[method]) {
          this.expectations[method] = [];
          var mock = this;

          sinon.wrapMethod(this.object, method, function () {
            return mock.invokeMethod(method, this, arguments);
          });

          this.proxies.push(method);
        }

        var expectation = sinon.expectation.create(method);
        this.expectations[method].push(expectation);

        return expectation;
      },

      restore: function restore() {
        var object = this.object;

        each(this.proxies, function (proxy) {
          if (typeof object[proxy].restore == "function") {
            object[proxy].restore();
          }
        });
      },

      verify: function verify() {
        var expectations = this.expectations || {};
        var exception;

        try {
          each(this.proxies, function (proxy) {
            each(expectations[proxy], function (expectation) {
              expectation.verify();
            });
          });
        } catch (e) {
          exception = e;
        }

        this.restore();

        if (exception) {
          throw exception;
        }

        return true;
      },

      invokeMethod: function invokeMethod(method, thisObj, args) {
        var expectations = this.expectations && this.expectations[method];
        var length = expectations && expectations.length || 0;

        for (var i = 0; i < length; i += 1) {
          if (!expectations[i].met()) {
            return expectations[i].apply(thisObj, args);
          }
        }

        return expectations[length - 1].apply(thisObj, args);
      }
    };
  }());

  function err(message) {
    var exception = new Error(message);
    exception.name = "ExpectationError";

    throw exception;
  }

  sinon.expectation = (function () {
    var slice = Array.prototype.slice;
    var _invoke = sinon.spy.invoke;

    function timesInWords(times) {
      if (times == 1) {
        return "once";
      } else if (times == 2) {
        return "twice";
      } else if (times == 3) {
        return "thrice";
      }

      return times + " times";
    }

    function receivedMinCalls(expectation) {
      var hasMinLimit = typeof expectation.minCalls == "number";
      return !hasMinLimit || expectation.callCount >= expectation.minCalls;
    }

    function receivedMaxCalls(expectation) {
      if (typeof expectation.maxCalls != "number") {
        return false;
      }

      return expectation.callCount == expectation.maxCalls;
    }

    return {
      minCalls: 1,
      maxCalls: 1,

      create: function create(methodName) {
        var expectation = sinon.extend(sinon.stub.create(), sinon.expectation);
        delete expectation.create;
        expectation.method = methodName;

        return expectation;
      },

      invoke: function invoke(func, thisObj, args) {
        this.verifyCallAllowed(thisObj, args);

        return _invoke.apply(this, arguments);
      },

      atLeast: function atLeast(num) {
        if (typeof num != "number") {
          throw new TypeError("'" + num + "' is not number");
        }

        if (!this.limitsSet) {
          this.maxCalls = null;
          this.limitsSet = true;
        }

        this.minCalls = num;

        return this;
      },

      atMost: function atMost(num) {
        if (typeof num != "number") {
          throw new TypeError("'" + num + "' is not number");
        }

        if (!this.limitsSet) {
          this.minCalls = null;
          this.limitsSet = true;
        }

        this.maxCalls = num;

        return this;
      },

      never: function never() {
        return this.exactly(0);
      },

      once: function once() {
        return this.exactly(1);
      },

      twice: function twice() {
        return this.exactly(2);
      },

      thrice: function thrice() {
        return this.exactly(3);
      },

      exactly: function exactly(num) {
        if (typeof num != "number") {
          throw new TypeError("'" + num + "' is not a number");
        }

        this.atLeast(num);
        return this.atMost(num);
      },

      met: function met() {
        return !this.failed && receivedMinCalls(this);
      },

      verifyCallAllowed: function verifyCallAllowed(thisObj, args) {
        if (receivedMaxCalls(this)) {
          this.failed = true;
          err(this.method + " already called " + timesInWords(this.maxCalls));
        }

        if ("expectedThis" in this && this.expectedThis !== thisObj) {
          err(this.method + " called with " + thisObj + " as thisObj, expected " +
              this.expectedThis);
        }

        if (!("expectedArguments" in this)) {
          return true;
        }

        if (!args || args.length === 0) {
          err(this.method + " received no arguments, expected " +
              this.expectedArguments.join());
        }

        if (args.length < this.expectedArguments.length) {
          err(this.method + " received too few arguments (" + args.join() +
              "), expected " + this.expectedArguments.join());
        }

        if (this.expectsExactArgCount &&
            args.length != this.expectedArguments.length) {
          err(this.method + " received too many arguments (" + args.join() +
              "), expected " + this.expectedArguments.join());
        }

        for (var i = 0, l = this.expectedArguments.length; i < l; i += 1) {
          if (!sinon.deepEqual(this.expectedArguments[i], args[i])) {
            err(this.method + " received wrong arguments (" + args.join() +
                "), expected " + this.expectedArguments.join());
          }
        }
      },

      withArgs: function withArgs() {
        this.expectedArguments = slice.call(arguments);
        return this;
      },

      withExactArgs: function withExactArgs() {
        this.withArgs.apply(this, arguments);
        this.expectsExactArgCount = true;
        return this;
      },

      on: function on(thisObj) {
        this.expectedThis = thisObj;
        return this;
      },

      verify: function verify() {
        if (!this.met()) {
          err(this.method + " expected to be called " + timesInWords(this.minCalls) +
              ", but was called " + timesInWords(this.callCount));
        }

        return true;
      }
    };
  }());

  if (commonJSModule) {
    module.exports = mock;
  } else {
    sinon.mock = mock;
  }
}(typeof sinon == "object" && sinon || null));
